<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stickman Parkour: Mobile Edition</title>
    <style>
        /* TOP TIER CSS: Optimized for mobile performance and preventing touch-drag */
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Prevents browser zooming/scrolling */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: fixed; /* CHANGED TO FIXED: Locks screen on mobile */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: transparent;
            max-width: 100%;
            max-height: 100%;
        }

        /* UI LAYERS */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 1px 1px 0 #fff;
            pointer-events: none;
        }

        /* SCREENS */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .hidden { display: none !important; }

        h1 { color: #fff; font-size: 40px; text-transform: uppercase; margin-bottom: 10px; text-align: center;}
        p { color: #ccc; font-size: 18px; text-align: center; max-width: 80%; }

        button.start-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 24px;
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 5px #c0392b;
        }
        button.start-btn:active { transform: translateY(4px); box-shadow: 0 1px #c0392b; }

        /* MOBILE CONTROLS */
        #controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 120px;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 5;
        }

        .control-group { display: flex; gap: 15px; }

        .btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            color: white;
            backdrop-filter: blur(5px);
            touch-action: none;
        }

        .btn:active, .btn.pressed { background: rgba(255, 255, 255, 0.6); }
        .jump-btn { background: rgba(255, 71, 87, 0.4); border-color: #ff4757; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        LIVES: <span id="lives-display">❤️❤️❤️❤️❤️</span><br>
        LEVEL: <span id="level-display">1</span>
    </div>

    <div id="start-screen" class="screen">
        <h1>Stick Parkour</h1>
        <p>Use arrows to move. Jump to survive.</p>
        <p>5 Levels. 5 Lives. Good luck.</p>
        <button class="start-btn" onclick="startGame()">START GAME</button>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h1 id="go-title">GAME OVER</h1>
        <p id="go-msg">You ran out of lives.</p>
        <button class="start-btn" onclick="resetGame()">TRY AGAIN</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <div class="btn" id="btn-left">←</div>
            <div class="btn" id="btn-right">→</div>
        </div>
        <div class="btn jump-btn" id="btn-jump">↑</div>
    </div>
</div>

<script>
/**
 * ARCHITECTURE NOTES:
 * We are using a pure JS class-based system.
 * - Physics are handled with simple AABB collision.
 * - Audio is synthesized (AudioContext) to avoid loading external assets.
 * - The stickman is procedurally drawn to allow for smooth animation.
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let animationId;

// Audio Context
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();

// --- SOUND ENGINE (Synthesizer) ---
const playSound = (type) => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    
    if (type === 'jump') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'die') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(50, now + 0.3);
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    } else if (type === 'win') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.setValueAtTime(600, now + 0.1);
        gainNode.gain.setValueAtTime(0.1, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
    }
};

// --- CONFIGURATION ---
const GRAVITY = 0.6;
const FRICTION = 0.8;
const MOVE_SPEED = 5;
const JUMP_FORCE = -12;
const MAX_LIVES = 5;

// --- GAME STATE ---
let gameState = {
    running: false,
    lives: MAX_LIVES,
    currentLevel: 0,
    cameraX: 0
};

// --- INPUT HANDLING ---
const keys = { right: false, left: false, up: false };

// Keyboard
window.addEventListener('keydown', (e) => {
    if(e.code === 'ArrowRight') keys.right = true;
    if(e.code === 'ArrowLeft') keys.left = true;
    if(e.code === 'ArrowUp' || e.code === 'Space') {
        if(!keys.up) player.jump();
        keys.up = true;
    }
});
window.addEventListener('keyup', (e) => {
    if(e.code === 'ArrowRight') keys.right = false;
    if(e.code === 'ArrowLeft') keys.left = false;
    if(e.code === 'ArrowUp' || e.code === 'Space') keys.up = false;
});

// Touch (mapped to virtual buttons)
const setupTouch = (id, key) => {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; btn.classList.add('pressed'); if(key === 'up') player.jump(); });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; btn.classList.remove('pressed'); });
    btn.addEventListener('mousedown', (e) => { keys[key] = true; btn.classList.add('pressed'); if(key === 'up') player.jump(); });
    btn.addEventListener('mouseup', (e) => { keys[key] = false; btn.classList.remove('pressed'); });
};
setupTouch('btn-left', 'left');
setupTouch('btn-right', 'right');
setupTouch('btn-jump', 'up');

// --- LEVEL DATA (Procedurally defined) ---
// Type: 0 = air, 1 = ground, 2 = spike, 3 = goal
const levels = [
    // Level 1: The Basics
    { 
        map: [
            {x: 0, y: 350, w: 800, h: 50, type: 1}, // Floor
            {x: 300, y: 280, w: 100, h: 20, type: 1}, // Plat
            {x: 500, y: 220, w: 100, h: 20, type: 1}, // Plat
            {x: 750, y: 280, w: 50, h: 250, type: 3} // Goal
        ]
    },
    // Level 2: Jumps & Hazards
    {
        map: [
            {x: 0, y: 350, w: 200, h: 50, type: 1},
            {x: 250, y: 350, w: 200, h: 50, type: 1},
            {x: 220, y: 390, w: 30, h: 30, type: 2}, // Spike
            {x: 500, y: 250, w: 100, h: 20, type: 1},
            {x: 700, y: 200, w: 200, h: 20, type: 1},
            {x: 880, y: 150, w: 40, h: 50, type: 3}
        ]
    },
    // Level 3: The Climb
    {
        map: [
            {x: 0, y: 350, w: 150, h: 50, type: 1},
            {x: 200, y: 300, w: 80, h: 20, type: 1},
            {x: 100, y: 220, w: 80, h: 20, type: 1},
            {x: 250, y: 150, w: 80, h: 20, type: 1},
            {x: 0, y: 390, w: 800, h: 20, type: 2}, // Floor is lava (spikes)
            {x: 400, y: 150, w: 300, h: 20, type: 1},
            {x: 680, y: 100, w: 40, h: 50, type: 3}
        ]
    },
    // Level 4: Precision
    {
        map: [
            {x: 0, y: 300, w: 100, h: 50, type: 1},
            {x: 150, y: 300, w: 30, h: 200, type: 1}, // Pillars
            {x: 250, y: 300, w: 30, h: 200, type: 1},
            {x: 350, y: 300, w: 30, h: 200, type: 1},
            {x: 450, y: 250, w: 100, h: 20, type: 1},
            {x: 480, y: 230, w: 40, h: 20, type: 2}, // Spike on platform
            {x: 650, y: 250, w: 100, h: 20, type: 3}
        ]
    },
    // Level 5: The Gauntlet
    {
        map: [
            {x: 0, y: 300, w: 100, h: 50, type: 1},
            {x: 150, y: 300, w: 50, h: 10, type: 1},
            {x: 250, y: 250, w: 50, h: 10, type: 1},
            {x: 350, y: 200, w: 50, h: 10, type: 1},
            {x: 150, y: 380, w: 500, h: 20, type: 2}, // Big spikes
            {x: 500, y: 200, w: 200, h: 20, type: 1},
            {x: 550, y: 180, w: 20, h: 20, type: 2}, // Spike
            {x: 650, y: 180, w: 20, h: 20, type: 2}, // Spike
            {x: 750, y: 150, w: 50, h: 50, type: 3}
        ]
    }
];

// --- PLAYER CLASS ---
class Player {
    constructor() {
        this.w = 20;
        this.h = 50;
        this.reset();
        this.color = '#333';
        this.walkFrame = 0;
    }

    reset() {
        this.x = 50;
        this.y = 200;
        this.vx = 0;
        this.vy = 0;
        this.grounded = false;
        this.dead = false;
    }

    jump() {
        if (this.grounded) {
            this.vy = JUMP_FORCE;
            this.grounded = false;
            playSound('jump');
        }
    }

    update() {
        // Physics
        if (keys.right) this.vx += 1;
        if (keys.left) this.vx -= 1;
        
        this.vx *= FRICTION;
        this.vy += GRAVITY;

        // Cap speed
        if (this.vx > MOVE_SPEED) this.vx = MOVE_SPEED;
        if (this.vx < -MOVE_SPEED) this.vx = -MOVE_SPEED;

        this.x += this.vx;
        this.y += this.vy;

        this.grounded = false;

        // Collision Check
        const level = levels[gameState.currentLevel];
        if (!level) return;

        // Boundaries (Death by falling)
        if (this.y > canvas.height + 100) {
            this.die();
        }

        for (let obj of level.map) {
            // AABB Collision
            if (this.x < obj.x + obj.w &&
                this.x + this.w > obj.x &&
                this.y < obj.y + obj.h &&
                this.y + this.h > obj.y) {
                
                // TYPE 1: Solid Ground
                if (obj.type === 1) {
                    // Collision resolution
                    let dx = (this.x + this.w / 2) - (obj.x + obj.w / 2);
                    let dy = (this.y + this.h / 2) - (obj.y + obj.h / 2);
                    let width = (this.w + obj.w) / 2;
                    let height = (this.h + obj.h) / 2;
                    let crossWidth = width * dy;
                    let crossHeight = height * dx;

                    if (Math.abs(dx) <= width && Math.abs(dy) <= height) {
                        if (crossWidth > crossHeight) {
                            if (crossWidth > -crossHeight) { // Bottom
                                this.y = obj.y + obj.h;
                                this.vy = 0;
                            } else { // Left
                                this.x = obj.x - this.w;
                                this.vx = 0;
                            }
                        } else {
                            if (crossWidth > -crossHeight) { // Right
                                this.x = obj.x + obj.w;
                                this.vx = 0;
                            } else { // Top (Landed)
                                this.y = obj.y - this.h;
                                this.vy = 0;
                                this.grounded = true;
                            }
                        }
                    }
                }
                // TYPE 2: Spike
                else if (obj.type === 2) {
                    this.die();
                }
                // TYPE 3: Goal
                else if (obj.type === 3) {
                    nextLevel();
                }
            }
        }
    }

    die() {
        if (this.dead) return;
        this.dead = true;
        playSound('die');
        gameState.lives--;
        updateUI();
        
        if (gameState.lives <= 0) {
            endGame();
        } else {
            // Soft reset
            setTimeout(() => {
                this.reset();
                this.dead = false;
            }, 500);
        }
    }

    draw(ctx) {
        // Procedural Stick Figure Animation
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        
        // Direction facing
        if (this.vx < -0.1) ctx.scale(-1, 1);

        ctx.strokeStyle = this.color;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';

        // Animation math
        this.walkFrame += Math.abs(this.vx) * 0.5;
        const legOffset = Math.sin(this.walkFrame) * 10;
        const armOffset = Math.cos(this.walkFrame) * 10;

        // Head
        ctx.beginPath();
        ctx.arc(0, -20, 8, 0, Math.PI * 2);
        ctx.stroke();

        // Body
        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.lineTo(0, 10);
        ctx.stroke();

        // Legs (animated)
        if (this.grounded) {
            // Walking
            ctx.beginPath();
            ctx.moveTo(0, 10);
            ctx.lineTo(-5 + legOffset, 25); // Leg 1
            ctx.moveTo(0, 10);
            ctx.lineTo(5 - legOffset, 25);  // Leg 2
            ctx.stroke();
        } else {
            // Jumping pose
            ctx.beginPath();
            ctx.moveTo(0, 10);
            ctx.lineTo(-8, 20); // Leg 1 up
            ctx.moveTo(0, 10);
            ctx.lineTo(8, 25);  // Leg 2 down
            ctx.stroke();
        }

        // Arms (animated)
        ctx.beginPath();
        ctx.moveTo(0, -5);
        ctx.lineTo(-8 - armOffset, 5);
        ctx.moveTo(0, -5);
        ctx.lineTo(8 + armOffset, 5);
        ctx.stroke();

        ctx.restore();
    }
}

const player = new Player();

// --- GAME LOOP & SYSTEM ---

function resize() {
    canvas.width = 1200; // INCREASED FOR ZOOM OUT (Was 800)
    canvas.height = 600; // INCREASED FOR ZOOM OUT (Was 400)
}
window.addEventListener('resize', resize);
resize();

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    gameState.lives = MAX_LIVES;
    gameState.currentLevel = 0;
    gameState.running = true;
    player.reset();
    updateUI();
    loop();
}

function resetGame() {
    startGame();
}

function nextLevel() {
    playSound('win');
    gameState.currentLevel++;
    if (gameState.currentLevel >= levels.length) {
        // Game Win Loop (or reset to 0)
        document.getElementById('go-title').innerText = "YOU WON!";
        document.getElementById('go-msg').innerText = "All levels cleared. Top tier gameplay.";
        endGame();
    } else {
        player.reset();
        updateUI();
    }
}

function endGame() {
    gameState.running = false;
    document.getElementById('game-over-screen').classList.remove('hidden');
    if(gameState.lives <= 0) {
        document.getElementById('go-title').innerText = "GAME OVER";
        document.getElementById('go-msg').innerText = "You ran out of lives.";
    }
}

function updateUI() {
    let hearts = "";
    for(let i=0; i<gameState.lives; i++) hearts += "❤️";
    document.getElementById('lives-display').innerText = hearts;
    document.getElementById('level-display').innerText = gameState.currentLevel + 1;
}

function loop() {
    if (!gameState.running) return;

    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Camera Follow logic (Smooth Pan)
    let targetCamX = player.x - canvas.width / 3;
    if (targetCamX < 0) targetCamX = 0;
    // Simple lerp for smoothness
    gameState.cameraX += (targetCamX - gameState.cameraX) * 0.1;

    ctx.save();
    ctx.translate(-gameState.cameraX, 0);

    // Draw Level
    const level = levels[gameState.currentLevel];
    if(level) {
        for (let obj of level.map) {
            if (obj.type === 1) ctx.fillStyle = '#444'; // Ground
            else if (obj.type === 2) ctx.fillStyle = '#e74c3c'; // Spike
            else if (obj.type === 3) ctx.fillStyle = '#2ecc71'; // Goal
            
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            
            // Draw Spike details
            if(obj.type === 2) {
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
            }
        }
    }

    // Update & Draw Player
    player.update();
    player.draw(ctx);

    ctx.restore();

    requestAnimationFrame(loop);
}

// Initial UI Update
updateUI();

</script>
</body>
</html>
