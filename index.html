<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Stickman Parkour: Mobile Edition</title>
    <style>
        /* TOP TIER CSS: Optimized for mobile performance and preventing touch-drag */
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Prevents browser zooming/scrolling */
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: fixed; /* Fixed prevents scrolling issues on mobile */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(to bottom, #87CEEB, #E0F7FA);
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background: transparent;
            max-width: 100%;
            max-height: 100%;
        }

        /* UI LAYERS */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            font-weight: bold;
            font-size: 24px;
            text-shadow: 1px 1px 0 #fff;
            pointer-events: none;
            z-index: 20;
        }

        /* SCREENS */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 30;
        }

        .hidden { display: none !important; }

        h1 { color: #fff; font-size: 40px; text-transform: uppercase; margin-bottom: 10px; text-align: center;}
        p { color: #ccc; font-size: 18px; text-align: center; max-width: 80%; }

        button.start-btn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 24px;
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 5px #c0392b;
        }
        button.start-btn:active { transform: translateY(4px); box-shadow: 0 1px #c0392b; }

        /* MOBILE CONTROLS */
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            height: 120px;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            box-sizing: border-box;
            z-index: 25;
            pointer-events: auto;
        }

        .control-group { display: flex; gap: 20px; }

        .btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            color: white;
            backdrop-filter: blur(5px);
            touch-action: none;
            user-select: none;
        }

        .btn:active, .btn.pressed { background: rgba(255, 255, 255, 0.6); transform: scale(0.95); }
        .jump-btn { background: rgba(255, 71, 87, 0.4); border-color: #ff4757; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        LIVES: <span id="lives-display">❤️❤️❤️❤️❤️</span><br>
        LEVEL: <span id="level-display">1</span>
    </div>

    <div id="start-screen" class="screen">
        <h1>Stick Parkour</h1>
        <p>Use arrows to move. Jump to survive.</p>
        <p>5 Levels. 5 Lives. Good luck.</p>
        <button id="start-btn" class="start-btn">START GAME</button>
    </div>

    <div id="game-over-screen" class="screen hidden">
        <h1 id="go-title">GAME OVER</h1>
        <p id="go-msg">You ran out of lives.</p>
        <button id="restart-btn" class="start-btn">TRY AGAIN</button>
    </div>

    <div id="controls">
        <div class="control-group">
            <div class="btn" id="btn-left">←</div>
            <div class="btn" id="btn-right">→</div>
        </div>
        <div class="btn jump-btn" id="btn-jump">↑</div>
    </div>
</div>

<script>
// --- ENGINE SETUP ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let audioCtx = null;

// ZOOM FIX: 1200x600 resolution creates the "Zoom Out" effect
function resize() {
    canvas.width = 1200; 
    canvas.height = 600;
}
window.addEventListener('resize', resize);
resize();

// --- CONFIGURATION ---
const GRAVITY = 0.6;
const FRICTION = 0.8;
const MOVE_SPEED = 6;
const JUMP_FORCE = -13;
const MAX_LIVES = 5;

// --- GAME STATE ---
let gameState = {
    running: false,
    lives: MAX_LIVES,
    currentLevel: 0,
    cameraX: 0
};

// --- AUDIO SYSTEM ---
function initAudio() {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(audioCtx.state === 'suspended') audioCtx.resume();
}

const playSound = (type) => {
    if (!audioCtx) return;
    try {
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        
        if (type === 'jump') {
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.exponentialRampToValueAtTime(300, now + 0.1);
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'die') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.3);
            gainNode.gain.setValueAtTime(0.2, now);
            gainNode.gain.linearRampToValueAtTime(0.01, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'win') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.setValueAtTime(600, now + 0.1);
            gainNode.gain.setValueAtTime(0.1, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        }
    } catch(e) {}
};

// --- INPUT HANDLING ---
const keys = { right: false, left: false, up: false };

// Keyboard
window.addEventListener('keydown', (e) => {
    if(e.code === 'ArrowRight') keys.right = true;
    if(e.code === 'ArrowLeft') keys.left = true;
    if(e.code === 'ArrowUp' || e.code === 'Space') {
        if(!keys.up) player.jump();
        keys.up = true;
    }
});
window.addEventListener('keyup', (e) => {
    if(e.code === 'ArrowRight') keys.right = false;
    if(e.code === 'ArrowLeft') keys.left = false;
    if(e.code === 'ArrowUp' || e.code === 'Space') keys.up = false;
});

// Touch Inputs
const setupTouch = (id, key) => {
    const btn = document.getElementById(id);
    const start = (e) => { e.preventDefault(); keys[key] = true; btn.classList.add('pressed'); if(key === 'up') player.jump(); };
    const end = (e) => { e.preventDefault(); keys[key] = false; btn.classList.remove('pressed'); };
    btn.addEventListener('touchstart', start, {passive: false});
    btn.addEventListener('touchend', end);
    btn.addEventListener('mousedown', start);
    btn.addEventListener('mouseup', end);
};
setupTouch('btn-left', 'left');
setupTouch('btn-right', 'right');
setupTouch('btn-jump', 'up');

// --- LEVEL DATA ---
const levels = [
    // Level 1
    { map: [{x:0,y:350,w:800,h:50,t:1}, {x:300,y:280,w:100,h:20,t:1}, {x:500,y:220,w:100,h:20,t:1}, {x:750,y:0,w:100,h:600,t:3}] },
    // Level 2
    { map: [{x:0,y:350,w:200,h:50,t:1}, {x:250,y:350,w:550,h:50,t:1}, {x:220,y:390,w:30,h:30,t:2}, {x:500,y:250,w:100,h:20,t:1}, {x:700,y:200,w:100,h:20,t:1}, {x:750,y:0,w:100,h:600,t:3}] },
    // Level 3
    { map: [{x:0,y:350,w:150,h:50,t:1}, {x:200,y:300,w:80,h:20,t:1}, {x:0,y:390,w:800,h:20,t:2}, {x:400,y:150,w:300,h:20,t:1}, {x:750,y:0,w:100,h:600,t:3}] },
    // Level 4
    { map: [{x:0,y:300,w:100,h:50,t:1}, {x:150,y:300,w:30,h:200,t:1}, {x:250,y:300,w:30,h:200,t:1}, {x:350,y:300,w:30,h:200,t:1}, {x:450,y:250,w:100,h:20,t:1}, {x:480,y:230,w:40,h:20,t:2}, {x:650,y:250,w:100,h:20,t:3}] },
    // Level 5
    { map: [{x:0,y:300,w:100,h:50,t:1}, {x:150,y:380,w:500,h:20,t:2}, {x:150,y:300,w:50,h:10,t:1}, {x:350,y:200,w:50,h:10,t:1}, {x:500,y:200,w:200,h:20,t:1}, {x:750,y:0,w:100,h:600,t:3}] }
];

// --- PLAYER CLASS ---
class Player {
    constructor() { this.w=20; this.h=50; this.reset(); this.color='#333'; this.walkFrame=0; }
    reset() { this.x=50; this.y=200; this.vx=0; this.vy=0; this.grounded=false; this.dead=false; }
    jump() { if (this.grounded) { this.vy=JUMP_FORCE; this.grounded=false; playSound('jump'); } }
    
    update() {
        if (keys.right) this.vx += 1;
        if (keys.left) this.vx -= 1;
        this.vx *= FRICTION;
        this.vy += GRAVITY;
        if (this.vx > MOVE_SPEED) this.vx = MOVE_SPEED;
        if (this.vx < -MOVE_SPEED) this.vx = -MOVE_SPEED;
        this.x += this.vx;
        this.y += this.vy;
        this.grounded = false;

        // Pit Death
        if (this.y > canvas.height + 100) { this.die(); return; }

        const level = levels[gameState.currentLevel];
        if (!level) return;

        for (let obj of level.map) {
            // Collision Check
            if (this.x < obj.x + obj.w && this.x + this.w > obj.x && this.y < obj.y + obj.h && this.y + this.h > obj.y) {
                if (obj.t === 3) { nextLevel(); return; } // Goal
                if (obj.t === 2) { this.die(); return; } // Spike
                if (obj.t === 1) { // Ground
                    let dx = (this.x + this.w/2) - (obj.x + obj.w/2);
                    let dy = (this.y + this.h/2) - (obj.y + obj.h/2);
                    let width = (this.w + obj.w)/2;
                    let height = (this.h + obj.h)/2;
                    let crossWidth = width * dy;
                    let crossHeight = height * dx;

                    if (Math.abs(dx) <= width && Math.abs(dy) <= height) {
                        if (crossWidth > crossHeight) {
                            if (crossWidth > -crossHeight) { this.y = obj.y + obj.h; this.vy = 0; } 
                            else { this.x = obj.x - this.w; this.vx = 0; }
                        } else {
                            if (crossWidth > -crossHeight) { this.x = obj.x + obj.w; this.vx = 0; } 
                            else { this.y = obj.y - this.h; this.vy = 0; this.grounded = true; }
                        }
                    }
                }
            }
        }
    }

    die() {
        if (this.dead) return;
        this.dead = true;
        playSound('die');
        gameState.lives--;
        updateUI();
        if (gameState.lives <= 0) endGame();
        else setTimeout(() => { this.reset(); this.dead=false; }, 500);
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        if (this.vx < -0.1) ctx.scale(-1, 1);
        ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.lineCap = 'round';
        this.walkFrame += Math.abs(this.vx) * 0.5;
        const l = Math.sin(this.walkFrame) * 10;
        const a = Math.cos(this.walkFrame) * 10;
        ctx.beginPath(); ctx.arc(0,-20,8,0,Math.PI*2); ctx.stroke(); // Head
        ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(0,10); ctx.stroke(); // Body
        if (this.grounded) { ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(-5+l,25); ctx.moveTo(0,10); ctx.lineTo(5-l,25); ctx.stroke(); } // Walk
        else { ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(-8,20); ctx.moveTo(0,10); ctx.lineTo(8,25); ctx.stroke(); } // Jump
        ctx.beginPath(); ctx.moveTo(0,-5); ctx.lineTo(-8-a,5); ctx.moveTo(0,-5); ctx.lineTo(8+a,5); ctx.stroke(); // Arms
        ctx.restore();
    }
}

const player = new Player();

// --- GAME LOGIC ---
document.getElementById('start-btn').onclick = startGame;
document.getElementById('restart-btn').onclick = startGame;

function startGame() {
    initAudio();
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    gameState.lives = MAX_LIVES;
    gameState.currentLevel = 0;
    gameState.running = true;
    player.reset();
    updateUI();
    loop();
}

function nextLevel() {
    playSound('win');
    gameState.currentLevel++;
    if (gameState.currentLevel >= levels.length) {
        document.getElementById('go-title').innerText = "YOU WON!";
        document.getElementById('go-msg').innerText = "All levels cleared!";
        endGame();
    } else {
        player.reset();
        updateUI();
    }
}

function endGame() {
    gameState.running = false;
    document.getElementById('game-over-screen').classList.remove('hidden');
    if(gameState.lives <= 0) {
        document.getElementById('go-title').innerText = "GAME OVER";
        document.getElementById('go-msg').innerText = "You ran out of lives.";
    }
}

function updateUI() {
    document.getElementById('lives-display').innerText = "❤️".repeat(gameState.lives);
    document.getElementById('level-display').innerText = gameState.currentLevel + 1;
}

function loop() {
    if (!gameState.running) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    let targetCamX = player.x - canvas.width / 3;
    if (targetCamX < 0) targetCamX = 0;
    gameState.cameraX += (targetCamX - gameState.cameraX) * 0.1;

    ctx.save();
    ctx.translate(-gameState.cameraX, 0);

    const level = levels[gameState.currentLevel];
    if(level) {
        for (let obj of level.map) {
            if (obj.t === 1) ctx.fillStyle = '#444';
            else if (obj.t === 2) ctx.fillStyle = '#e74c3c';
            else if (obj.t === 3) ctx.fillStyle = '#2ecc71';
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            if(obj.t === 2) { ctx.strokeStyle='#fff'; ctx.strokeRect(obj.x, obj.y, obj.w, obj.h); }
        }
    }

    player.update();
    player.draw(ctx);
    ctx.restore();
    requestAnimationFrame(loop);
}
updateUI();
</script>
</body>
</html>
